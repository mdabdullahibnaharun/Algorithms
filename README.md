# Algorithm Repository

This repository contains a collection of classic and efficient algorithms implemented in C++. The algorithms cover a wide range of topics, from sorting and searching to graph theory and dynamic programming. They serve as a great resource for learning, reference, and practical implementation.

## Algorithms List

### 1. **BFS Adjacency Matrix**
   - **Description**: Implements the Breadth-First Search (BFS) algorithm using an adjacency matrix.
   
### 2. **Binary Search**
   - **Description**: An efficient algorithm to search for an element in a sorted array with time complexity of O(log n).

### 3. **Binary Tree Creation**
   - **Description**: Creates a binary tree structure, essential for various tree traversal algorithms.

### 4. **Binary Tree Traversal (TREEWALK)**
   - **Description**: Implements In-order, Pre-order, and Post-order traversal techniques for binary trees.

### 5. **Bubble Sort**
   - **Description**: A simple, comparison-based sorting algorithm with time complexity of O(n²). Easy to understand but inefficient for large datasets.

### 6. **Dijkstra's Algorithm**
   - **Description**: Finds the shortest path in a weighted graph using Dijkstra’s algorithm. Ideal for graph traversal.

### 7. **Euclid's GCD Algorithm**
   - **Description**: Computes the greatest common divisor (GCD) of two numbers using the efficient Euclidean algorithm.

### 8. **Floyd-Warshall Algorithm**
   - **Description**: A dynamic programming algorithm used to find the shortest paths in a weighted graph with multiple nodes.

### 9. **Greedy Coin Change**
   - **Description**: Solves the coin change problem using a greedy approach, aiming to minimize the number of coins.

### 10. **Heap Sort**
   - **Description**: A comparison-based sorting algorithm that utilizes a binary heap data structure. Efficient with a time complexity of O(n log n).

### 11. **Insertion Sort**
   - **Description**: A simple, intuitive sorting algorithm that builds the sorted array one item at a time.

### 12. **Longest Common Subsequence (LCS)**
   - **Description**: Solves the Longest Common Subsequence problem using dynamic programming to find the longest subsequence common to two sequences.

### 13. **Longest Increasing Subsequence (LIS)**
   - **Description**: Finds the longest increasing subsequence in an array using dynamic programming.

### 14. **Linear Search**
   - **Description**: A simple searching algorithm that sequentially checks each element in an array for a match.

### 15. **Merge Sort**
   - **Description**: A divide-and-conquer sorting algorithm that splits the array into smaller sub-arrays and merges them back together in sorted order.

### 16. **Queue Data Structure**
   - **Description**: Implements a queue data structure that follows First In, First Out (FIFO) order for element processing.

### 17. **Quick Sort**
   - **Description**: A divide-and-conquer sorting algorithm that picks a pivot and partitions the array for efficient sorting.

### 18. **QuickSort using Pivot**
   - **Description**: A variation of Quick Sort where the array is partitioned using a pivot element for faster sorting.

### 19. **Selection Sort**
   - **Description**: A simple sorting algorithm that repeatedly selects the smallest (or largest) element and swaps it with the first unsorted element.

### 20. **Stack Data Structure**
   - **Description**: Implements a stack data structure with push and pop operations, following the Last In, First Out (LIFO) principle.

### 21. **Tower of Hanoi**
   - **Description**: A classic algorithm to solve the Tower of Hanoi puzzle, involving recursive problem-solving to move disks between pegs.

### 22. **Warshall's Algorithm (1 & 2)**
   - **Description**: Implementations of Warshall's algorithm for finding transitive closures and shortest paths in a graph.

### 23. **Palindrome Check**
   - **Description**: Determines whether a given string is a palindrome, i.e., it reads the same forward and backward.

### 24. **Knapsack Problem**
   - **Description**: Solves the 0/1 knapsack problem using dynamic programming to maximize the value carried in a knapsack given a set of items.

### 25. **Sieve of Eratosthenes**
   - **Description**: An efficient algorithm to find all prime numbers up to a specified integer using the sieve method.

---

## Usage

Each algorithm is implemented in C++ and can be used as-is or integrated into larger projects. You can either clone the repository or download individual files based on your requirements.

## Contributing

Feel free to fork this repository, contribute new algorithms, or report any issues you encounter. All contributions are welcome!



Thank you for exploring this algorithm collection! Happy coding!
